#!/usr/bin/env node

const fs = require('node:fs')
const path = require('node:path')

// Configuraci√≥n
const USERS_FILE = path.join(__dirname, '../dist/domain/users.d.ts')
const OUTPUT_DIR = path.join(__dirname, '../../../apis/users/app/Types')
const NAMESPACE = 'App\\Types'

// Mapeo de tipos TypeScript a PHP
const typeMap = {
	string: 'string',
	number: 'int|float',
	boolean: 'bool',
	Date: '\\DateTime',
	any: 'mixed',
	unknown: 'mixed',
	void: 'void',
	null: 'null',
	undefined: 'null',
}

/**
 * Convierte un tipo TypeScript a tipo PHP
 */
function convertType(tsType) {
	if (!tsType) return 'mixed'

	// Remover espacios y saltos de l√≠nea
	tsType = tsType.trim()

	// Arrays
	if (tsType.endsWith('[]')) {
		return 'array'
	}

	// Array<T>
	if (tsType.startsWith('Array<')) {
		return 'array'
	}

	// Tipos b√°sicos
	if (typeMap[tsType]) {
		return typeMap[tsType]
	}

	// Si es un tipo personalizado, lo dejamos como est√°
	return tsType
}

/**
 * Genera el docblock de una propiedad
 */
function generatePropertyDocblock(_, type, isOptional = false) {
	const phpType = convertType(type)
	const nullable = isOptional ? '|null' : ''

	return `    /**
     * @var ${phpType}${nullable}
     */`
}

/**
 * Parsea una interfaz TypeScript y genera una clase PHP
 */
function parseInterface(content, interfaceName) {
	const regex = new RegExp(
		`export interface ${interfaceName}\\s*\\{([^}]+)\\}`,
		's',
	)
	const match = content.match(regex)

	if (!match) return null

	const body = match[1]
	const properties = []
	const methods = []

	// Separar l√≠neas y procesar cada una
	const lines = body
		.split('\n')
		.map((line) => line.trim())
		.filter((line) => line && line !== ';')

	for (const line of lines) {
		// Verificar si es un m√©todo (tiene par√©ntesis)
		if (line.includes('(') && line.includes(')')) {
			// Es un m√©todo
			const methodMatch = line.match(/(\w+)\s*\(([^)]*)\)\s*:\s*(.+);?/)
			if (methodMatch) {
				const [, name, params, returnType] = methodMatch

				// Parsear par√°metros
				const parsedParams = []
				if (params.trim()) {
					const paramParts = params.split(',')
					paramParts.forEach((param) => {
						const paramMatch = param.trim().match(/(\w+)(\?)?:\s*(.+)/)
						if (paramMatch) {
							const [, paramName, optional, paramType] = paramMatch
							parsedParams.push({
								name: paramName,
								type: paramType.trim(),
								optional: !!optional,
							})
						}
					})
				}

				methods.push({
					name,
					params: parsedParams,
					returnType: returnType.trim().replace(/;$/, ''),
				})
			}
		} else {
			// Es una propiedad
			const propMatch = line.match(/(\w+)(\?)?:\s*([^;]+);?/)
			if (propMatch) {
				const [, name, optional, type] = propMatch
				properties.push({
					name,
					type: type.trim(),
					optional: !!optional,
				})
			}
		}
	}

	return { interfaceName, properties, methods }
}

/**
 * Genera una clase PHP a partir de una interfaz TypeScript
 */
function generatePhpClass(interfaceData, domain) {
	const { interfaceName, properties, methods } = interfaceData
	const domainNamespace = domain
		? `\\${domain.charAt(0).toUpperCase() + domain.slice(1)}`
		: ''

	let phpCode = `<?php

declare(strict_types=1);

namespace ${NAMESPACE}${domainNamespace};

`

	// Determinar si es un DTO o una entidad
	const isDto = interfaceName.includes('Dto')
	const isRepository = interfaceName.includes('Repository')

	if (isRepository || methods.length > 0) {
		// Para repositories e interfaces con m√©todos, crear una interfaz PHP
		phpCode += `/**
 * Repository interface for ${interfaceName.replace('Repository', '')}
 * 
 * Auto-generated from TypeScript definitions
 * DO NOT EDIT THIS FILE MANUALLY
 */
interface ${interfaceName}
{
`

		// Generar m√©todos
		methods.forEach((method) => {
			// Convertir tipo de retorno
			let returnType = method.returnType
			let isNullable = false

			// Manejar Promise<Type>
			const promiseMatch = returnType.match(/Promise<(.+)>/)
			if (promiseMatch) {
				returnType = promiseMatch[1]
			}

			// Manejar Type | null
			if (returnType.includes('|')) {
				const types = returnType.split('|').map((t) => t.trim())
				if (types.includes('null')) {
					isNullable = true
					returnType = types.filter((t) => t !== 'null').join('|')
				}
			}

			const phpReturnType = convertType(returnType)
			const nullablePrefix = isNullable ? '?' : ''

			// Generar docblock
			phpCode += `    /**
`
			method.params.forEach((param) => {
				const phpParamType = convertType(param.type)
				phpCode += `     * @param ${phpParamType} $${param.name}
`
			})
			phpCode += `     * @return ${nullablePrefix}${phpReturnType}
`
			phpCode += `     */
`

			// Generar firma del m√©todo
			phpCode += `    public function ${method.name}(`

			method.params.forEach((param, index) => {
				const phpParamType = convertType(param.type)
				const nullable = param.optional ? '?' : ''
				const comma = index < method.params.length - 1 ? ', ' : ''
				phpCode += `${nullable}${phpParamType} $${param.name}${comma}`
			})

			phpCode += `): ${nullablePrefix}${phpReturnType};

`
		})

		phpCode += `}
`
	} else {
		// Para DTOs y entidades, crear clases
		phpCode += `/**
 * ${isDto ? 'Data Transfer Object' : 'Entity'} for ${interfaceName}
 * 
 * Auto-generated from TypeScript definitions
 * DO NOT EDIT THIS FILE MANUALLY
 */
class ${interfaceName}
{
`

		// Generar propiedades
		properties.forEach((prop) => {
			phpCode += generatePropertyDocblock(prop.name, prop.type, prop.optional)
			phpCode += `
    public ${convertType(prop.type)} $${prop.name};

`
		})

		// Constructor
		if (properties.length > 0) {
			phpCode += `    public function __construct(
`

			properties.forEach((prop, index) => {
				const phpType = convertType(prop.type)
				const nullable = prop.optional ? '?' : ''
				const defaultValue = prop.optional ? ' = null' : ''
				const comma = index < properties.length - 1 ? ',' : ''

				phpCode += `        ${nullable}${phpType} $${prop.name}${defaultValue}${comma}
`
			})

			phpCode += `    ) {
`

			properties.forEach((prop) => {
				phpCode += `        $this->${prop.name} = $${prop.name};
`
			})

			phpCode += `    }

`
		}

		// M√©todos helper
		phpCode += `    /**
     * Convert to array
     */
    public function toArray(): array
    {
        return [
`

		properties.forEach((prop) => {
			phpCode += `            '${prop.name}' => $this->${prop.name},
`
		})

		phpCode += `        ];
    }

    /**
     * Create from array
     */
    public static function fromArray(array $data): self
    {
        return new self(
`

		properties.forEach((prop, index) => {
			const comma = index < properties.length - 1 ? ',' : ''
			phpCode += `            $data['${prop.name}'] ?? null${comma}
`
		})

		phpCode += `        );
    }
`

		phpCode += `}
`
	}

	return phpCode
}

/**
 * Procesa un archivo .d.ts y genera los archivos PHP correspondientes
 */
function processTypeDefinitionFile(filePath, domain = null) {
	const content = fs.readFileSync(filePath, 'utf-8')

	// Encontrar todas las interfaces exportadas
	const interfaceRegex = /export interface (\w+)/g
	let match
	const interfaces = []

	// biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
	while ((match = interfaceRegex.exec(content)) !== null) {
		interfaces.push(match[1])
	}

	// Generar clase PHP para cada interfaz
	interfaces.forEach((interfaceName) => {
		const interfaceData = parseInterface(content, interfaceName)

		if (interfaceData) {
			const phpCode = generatePhpClass(interfaceData, domain)

			// Determinar la ruta de salida
			const domainDir = domain
				? path.join(
						OUTPUT_DIR,
						domain.charAt(0).toUpperCase() + domain.slice(1),
					)
				: OUTPUT_DIR

			// Crear directorio si no existe
			if (!fs.existsSync(domainDir)) {
				fs.mkdirSync(domainDir, { recursive: true })
			}

			const outputPath = path.join(domainDir, `${interfaceName}.php`)
			fs.writeFileSync(outputPath, phpCode)
			console.log(`‚úì Generated: ${path.relative(process.cwd(), outputPath)}`)
		}
	})
}

/**
 * Funci√≥n principal
 */
function main() {
	console.log('üöÄ Generating PHP types from TypeScript definitions...\n')

	// Limpiar directorio de salida
	if (fs.existsSync(OUTPUT_DIR)) {
		fs.rmSync(OUTPUT_DIR, { recursive: true })
	}

	fs.mkdirSync(OUTPUT_DIR, { recursive: true })

	// Procesar solo el archivo users.d.ts
	if (fs.existsSync(USERS_FILE)) {
		processTypeDefinitionFile(USERS_FILE, 'users')
	} else {
		console.error(`‚ùå File not found: ${USERS_FILE}`)
		process.exit(1)
	}

	// Crear archivo .gitkeep para mantener la estructura
	const gitkeepPath = path.join(OUTPUT_DIR, '.gitkeep')
	fs.writeFileSync(gitkeepPath, '')

	console.log('\n‚úÖ PHP types generation completed!')
}

// Ejecutar
main()
